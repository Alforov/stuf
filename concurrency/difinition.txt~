read-modify-write-operation classic ThreadNotSafeOperaion like "count++"

When a thread reads a variable without synchronization, it may see a stale value, but at least it sees a value that was
actually placed there by some thread rather than some random value. This safety guarantee is called "out of thin air"
safety
OutͲofͲthinͲair safety applies to all variables, with one exception: 64Ͳbit numeric variables (double and long) that are
not declared volatile

mutex - mutual exclusion lock

Locking is not just about mutual exclusion; it is also about memory visibility. To ensure that all threads see the most upͲ
toͲdate values of shared mutable variables, the reading and writing threads must synchronize on a common lock.

The Java language also provides an alternative, weaker form of synchronization, volatile variables, to ensure that
updates to a variable are propagated predictably to other threads. When a field is declared volatile, the compiler and
runtime are put on notice that this variable is shared and that operations on it should not be reordered with other
memory operations. Volatile variables are not cached in registers or in caches where they are hidden from other
processors, so a read of a volatile variable always returns the most recent write by any thread

volatile boolean asleep;
...
 while (!asleep)
 countSomeSheep();
Volatile variables are convenient, but they have limitations. The most common use for volatile variables is as a
completion, interruption, or status flag, such as the asleep flag in Listing

Locking can guarantee both visibility and atomicity; volatile variables can only guarantee visibility.
You can use volatile variables only when all the following criteria are met:
x Writes to the variable do not depend on its current value, or you can ensure that only a single thread ever
updates the value;
x The variable does not participate in invariants with other state variables; and
x Locking is not required for any other reason while the variable is being accessed.





Thread Confinement - this technic use to avoid race condition 

Accessing shared, mutable data requires using synchronization; one way to avoid this requirement is to not share. If
data is only accessed from a single thread, no synchronization is needed. This technique, thread confinement, is one of
the simplest ways to achieve thread safety. When an object is confined to a thread, such usage is automatically threadͲ
safe even if the confined object itself is not [CPJ 2.3.2]
Another common application of thread confinement is the use of pooled JDBC (Java Database Connectivity) Connection
objects. The JDBC specification does not require that Connection objects be threadͲsafe.[9] In typical server applications,
a thread acquires a connection from the pool, uses it for processing a single request, and returns it.


Ad-hoc Thread Confinement


Stack Confinement
Stack confinement is a special case of thread confinement in which an object can only be reached through local
variables
ThreadLocal
private static ThreadLocal<Connection> connectionHolder
 = new ThreadLocal<Connection>() {
 public Connection initialValue() {
 return DriverManager.getConnection(DB_URL);
 }
 };
public static Connection getConnection() {
 return connectionHolder.get();
}



3.4. Immutability
The other endͲrun around the need to synchronize is to use immutable objects [EJ Item 13]. Nearly all the atomicity and
visibility hazards we've described so far, such as seeing stale values, losing updates, or observing an object to be in an
inconsistent state, have to do with the vagaries of multiple threads trying to access the same mutable state at the same
time. If an object's state cannot be modified, these risks and complexities simply go away.

An object is immutable if:
x Its state cannot be modified after construction;
x All its fields are final;
[12] and
x It is properly constructed (the this reference does not escape during construction). 



3.4.1. Final Fields
The final keyword, a more limited version of the const mechanism from C++, supports the construction of immutable
objects. Final fields can't be modified (although the objects they refer to can be modified if they are mutable), but they
also have special semantics under the Java Memory Model. It is the use of final fields that makes possible the guarantee
of initialization safety (see Section 3.5.2) that lets immutable objects be freely accessed and shared without
synchronization.




3.5. Safe Publication
So far we have focused on ensuring that an object not be published, such as when it is supposed to be confined to a
thread or within another object. Of course, sometimes we do want to share objects across threads, and in this case we
must do so safely. Unfortunately, simply storing a reference to an object into a public field, as in Listing 3.14, is not
enough to publish that object safely











