
4.2.1. The Java Monitor Pattern
The Java Monitor Pattern
public class PrivateLock {
 private final Object myLock = new Object();
 @GuardedBy("myLock") Widget widget;
 void someMethod() {
 synchronized(myLock) {
 // Access or modify the state of widget
 }
 }
} 

4.3. Delegating Thread Safety
All but the most trivial objects are composite objects. The Java monitor pattern is useful when building classes from
scratch or composing classes out of objects that are not threadͲsafe. But what if the components of our class are already
threadͲsafe? Do we need to add an additional layer of thread safety? The answer is . . . "it depends". In some cases a
composite made of threadͲsafe components is threadͲsafe (Listings 4.7 and 4.9), and in others it is merely a good start
(4.10).

delegation helps to avoid locks


4.3.2. Independent State Variables
The delegation examples so far delegate to a single, threadͲsafe state variable. We can also delegate thread safety to
more than one underlying state variable as long as those underlying state variables are independent, meaning that the
composite class does not impose any invariants involving the multiple state variables.

4.3.3. When Delegation Fails
Most composite classes are not as simple as VisualComponent: they have invariants that relate their component state
variables. NumberRange in Listing 4.10 uses two AtomicIntegers to manage its state, but imposes an additional
constraintͲthat the first number be less than or equal to the second.

