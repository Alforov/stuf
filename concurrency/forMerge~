The most useful policies for using and sharing objects in a concurrent program are:
ThreadͲconfined. A threadͲconfined object is owned exclusively by and confined to one thread, and can be modified by
its owning thread.
Shared readͲonly. A shared readͲonly object can be accessed concurrently by multiple threads without additional
synchronization, but cannot be modified by any thread. Shared readͲonly objects include immutable and effectively
immutable objects.
Shared threadͲsafe. A threadͲsafe object performs synchronization internally, so multiple threads can freely access it
through its public interface without further synchronization.
Guarded. A guarded object can be accessed only with a specific lock held. Guarded objects include those that are
encapsulated within other threadͲsafe objects and published objects that are known to be guarded by a specific lock.

While it is possible to write a threadͲsafe program that stores all its state in public static fields, it is a lot harder to verify
its thread safety or to modify it so that it remains threadͲsafe than one that uses encapsulation appropriately.
Encapsulation makes it possible to determine that a class is threadͲsafe without having to examine the entire program.
The design process for a threadͲsafe class should include these three basic elements:
x Identify the variables that form the object's state;
x Identify the invariants that constrain the state variables;
x Establish a policy for managing concurrent access to the object's state.
An object's state starts with its fields. If they are all of primitive type, the fields comprise the entire state. Counter in
Listing 4.1 has only one field, so the value field comprises its entire state. T


4.2. Instance Confinement
If an object is not threadͲsafe, several techniques can still let it be used safely in a multithreaded program. You can
ensure that it is only accessed from a single thread (thread confinement), or that all access to it is properly guarded by a
lock.
Encapsulating data within an object confines access to the data to the object's methods, making it easier to ensure that
the data is always accessed with the appropriate lock held.
Confined objects must not escape their intended scope. An object may be confined to a class instance (such as a private
class member), a lexical scope (such as a local variable), or a thread (such as an object that is passed from method to
method within a thread, but not supposed to be shared across threads). Objects don't escape on their own, of courseͲ
they need help from the developer, who assists by publishing the object beyond its intended scope.
@ThreadSafe
public class PersonSet {
 @GuardedBy("this")
 private final Set<Person> mySet = new HashSet<Person>();
 public synchronized void addPerson(Person p) {
 mySet.add(p);
 }
 public synchronized boolean containsPerson(Person p) {
 return mySet.contains(p);
 }
