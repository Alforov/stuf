Java developer basic knowledge.

Communication between server side and client(like Web-browser).In most cases for this purpose we use HTTP.
Before considering HTTP let's see what is encoding and URL.
---------------------------------------------------------------------------------------------------------------------------
ASCII abbreviated from American Standard Code for Information Interchange, is a character encoding standard for electronic communication
ASCII reserves the first 32 codes (numbers 0–31 decimal) for control characters:
The original ASCII table is encoded on 7 bits therefore it has 128 characters.
Nowadays most readers/editors use an "extended" ASCII table (from ISO 8859-1), which is encoded on 8 bits and
enjoys 256 characters (including Á, Ä, Œ, é, è and other characters useful for european languages as well as mathematical glyphs and
other symbols).

Unicode is a computing industry standard for the consistent encoding, representation, and handling of text
Unicode: 16 binary digits. 65536 characters.
Extend Unicode: 32 binary digits
In Java we use char is consist from 2 bytes or 16 bites or in base-10 0..65535 or in base-16 \u0000.. \uffff
char ch = 'a';
char uniChar = '\u03A9';



Unicode Transformation Format(UTF-8)
Thus was invented the brilliant concept of UTF-8.
UTF-8 was another system for storing your string of Unicode code points, those magic U+ numbers, in memory using 8 bit bytes.
In UTF-8, every code point from 0-127 is stored in a single byte.
Only code points 128 and above are stored using 2, 3, in fact, up to 6 bytes.

If you have a string, in memory, in a file, or in an email message,
you have to know what encoding it is in or you cannot interpret it or display it to users correctly.

Base64
t's basically a way of encoding arbitrary binary data in ASCII text.
It takes 4 characters per 3 bytes of data, plus potentially a bit of padding at the end.
Base64 use for saving bytes in text.
HTTP it's text protocol, so for transferring bytes we use base64.



---------------------------------------------------------------------------------------------------------------------------
Uniform Resource Locator (URL) is a reference to a web resource that specifies its location on a computer network.
A URL is a specific type of Uniform Resource Identifier(URI)
Every HTTP URL conforms to the syntax of a generic URI. A generic URI is of the form:
         scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]

Examples of schemes include: http(s), ftp, mailto, file, data

Authority part user [user[:password] An optional authentication section of a user name and password,
separated by a colon, followed by an at symbol (@)

A host, consisting of either a registered name (including but not limited to a hostname), or an IP address.

An optional [port] number, separated from the hostname by a colon

A path, which contains data, usually organized in hierarchical form, that appears as a sequence of segments separated by slashes

An optional query, separated from the preceding part by a question mark (?), containing a query string of non-hierarchical data.
Its syntax is not well defined, but by convention is most often a sequence of attribute–value pairs separated by a delimiter.

An optional fragment, separated from the preceding part by a hash (#).
The fragment contains a fragment identifier providing direction to a secondary resource,
such as a section heading in an article identified by the remainder of the URI.
When the primary resource is an HTML document, the fragment is often an id attribute of a specific element,
and web browsers will scroll this element into view.

Example URL:  http://login:password@localhost:9999/UPBS/paymentBroker/PaymentBroker-Service
If we input this URL in browser, browser will make GET request with basic authorization header (Authorization: Basic bG9naW46cGFzc3dvcmQ=)

URL encoding(Percent-encoding)
URLs can only be sent over the Internet using the ASCII character-set.
Since URLs often contain characters outside the ASCII set, the URL has to be converted into a valid ASCII format.
URL encoding replaces unsafe ASCII characters with a "%" followed by two hexadecimal digits.
URLs cannot contain spaces. URL encoding normally replaces a space with a plus (+) sign or with %20.


---------------------------------------------------------------------------------------------------------------------------
So, let's consider what is HTTP and how we should use it.
The Hypertext Transfer Protocol (HTTP) is an application protocol for distributed, collaborative, and hypermedia information systems
Hypertext is structured text that uses logical links (hyperlinks) between nodes containing text. HTTP is the protocol to exchange or transfer hypertext.
HTTP functions as a request–response protocol in the client–server computing model.
HTTP is designed to permit intermediate network elements to improve or enable communications between clients and servers.
Year	HTTP Version
1991	   0.9
1996	   1.0
1997	   1.1
2015	   2.0

Proxy support and the Host field:
HTTP 1.1 has a required Host header by spec.
This header is useful because it allows you to route a message through proxy servers,
and also because your web server can distinguish between different sites on the same server.

Persistent connections:
HTTP 1.1 also allows you to have persistent connections which means that you can have
more than one request/response on the same HTTP connection.
In HTTP 1.0 you had to open a new connection for each request/response pair. And after each response the connection would be closed.
This lead to some big efficiency problems because of TCP Slow Start.

OPTIONS method:
HTTP/1.1 introduces the OPTIONS method. An HTTP client can use this method to determine the abilities of the HTTP server.
It's mostly used for Cross Origin Resource Sharing in web applications.

HTTP/2 is a binary, rather than text, protocol, making it more compact and efficient
It uses a single, multiplexed connection per domain, rather than multiple connections carrying one file each
Headers are compressed with the purpose‑built HPACK protocol (rather than gzip, as in SPDY)
HTTP/2 has a complex prioritization scheme to help browsers request the most‑needed files first,
which is fully supported in NGINX (SPDY had a simpler scheme)



Example of request:       GET /wiki/HTTP HTTP/1.0
                          Host: www.blahblahblahblah.com

Request consist from METHOD,URI(Uniform Resource Identifier) and http version
METHODS:
                                                                                   Idempotent                Safe
    GET     Return state of resource                                                    Y                       Y
	HEAD	Same as GET but returns only HTTP headers and no document body              Y                       Y
	OPTIONS	Returns the HTTP methods that the server supports                           Y                       Y
	POST    Create resource                                                             N                       N
	PUT	    Uploads a representation of the specified URI                               Y                       N
	PATCH   Change some part of resource                                                N                       N
	DELETE	Deletes the specified resource                                              Y                       N

Example of response:     HTTP/1.0 200 OK

Response consist from  http version and response code.
Some most usage codes:
1xx: Informational (информационные):
2xx: Success (успешно):
200 OK («хорошо»)[2][3];
201 Created («создано»)[2][3][4];
202 Accepted («принято»)[2][3];
203 Non-Authoritative Information («информация не авторитетна»)[2][3];
3xx: Redirection (перенаправление):
4xx: Client Error (ошибка клиента):
400 Bad Request («плохой, неверный запрос»)[2][3][4];
401 Unauthorized («не авторизован»)[2][3];
403 Forbidden («запрещено»)[2][3];
404 Not Found («не найдено»)[2][3];
405 Method Not Allowed («метод не поддерживается»)[2][3];
406 Not Acceptable («неприемлемо»)[2][3];
5xx: Server Error (ошибка сервера):
500 Internal Server Error («внутренняя ошибка сервера»)[2][3];
501 Not Implemented («не реализовано»)[2][3];
502 Bad Gateway («плохой, ошибочный шлюз»)[2][3];
503 Service Unavailable («сервис недоступен»)[2][3];
504 Gateway Timeout («шлюз не отвечает»)[2][3];


Headers
HTTP header fields are components of the header section of request and response messages in the Hypertext Transfer Protocol (HTTP).
frequently used request headers:
They define the operating parameters of an HTTP transaction.
Accept	        Content-Types that are acceptable for the response. See Content negotiation.	Accept: text/plain
Accept-Charset	Character sets that are acceptable.                                 	        Accept-Charset: utf-8
Authorization   Authentication credentials for HTTP authentication.                             Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
Cookie	        An HTTP cookie previously sent by the server with Set-Cookie (below).	        Cookie: $Version=1; Skin=new;
Content-Length  The length of the request body in octets (8-bit bytes).	                        Content-Length: 348
Content-Type	The MIME type of the body of the request (used with POST and PUT requests).  	Content-Type: application/x-www-form-urlencoded
Host	        The domain name of the server (for virtual hosting)                             Host: en.wikipedia.org:8080Host: en.wikipedia.org



Cookies
Cookies are key/value pairs used by websites to store state informations on the browser.
Say you have a website (example.com), when the browser requests a webpage the website can send cookies to store informations on the browser.
Cookies are HTTP Headers. The header is called Cookie:, and it contains your cookie.
GET /index.html HTTP/1.1
Host: www.example.com

HTTP/1.1 200 OK
Content-type: text/html
Set-Cookie: foo=10
Set-Cookie: bar=20; Expires=Fri, 30 Sep 2011 11:48:00 GMT
... rest  of the response

GET /spec.html HTTP/1.1
Host: www.example.com
Cookie: foo=10; bar=20
Accept: */*

Cookie Pros:
scalability: all the data is stored in the browser so each request can go through a load balancer to different webservers and you have all the informations needed to fullfill the request;
they can be accessed via javascript on the browser;
not being on the server they will survive server restarts;
RESTful: requests don't depend on server state
Cookie Cons:
storage is limited to 80 KB (20 cookies, 4 KB each)
secure cookies are not easy to implement

Cookie in Java:
1. What is Cookie?
For us, Cookie is a class from javax.servlet.http package.
But in the open world, a Cookie represents a sweet Biscuit or Chocolate.

2. What a Cookie can store?
Cookie stores small strings of data. Cookies stay all through the session.
Programmer can store the session data with Cookie object.
It is another style of tracking session data (the first way is using HttpSession interface).

3. Who creates Cookies and where they are stored?
Servlet Cookies are created on the server (by Servlet container) and sent to the client’s browser for temporary storage.
The Servlet Cookies can be sent to and fro between client and server in their conversation.
Client is not aware of the entire process of Cookie management as everything is done by the server and
client is kept completely transparent.

4. What Cookie can do in Servlets?
Servlet Cookies are used mainly for tracking different types of client’s information. That is, the Web server can store data on the client browser in the form of Cookie objects.
Typical uses of a Cookie are
To store User name and Password
To write Shopping cart in e-Commerce application
Advertisement on client browser
Customization of Web sites etc.

Session Cookies: Session cookies get expired and deleted from browser when the browser closes, thereby,
they do not carry any expiration time constraint parameter.
They are stored temporarily (just for the usage of session) in the RAM memory.

Persistent Cookies: As the name indicates, they persist long time on the client browser.
The time of expiration can be set programmatically for each Cookie.
These Cookies are stored on hard disk. The Cookie gets deleted automatically when the time or age expires.

--------------------------------------------------------------------------------------------------------------------------
HTTPS
HTTPS (also called HTTP over Transport Layer Security [TLS], HTTP over SSL, and HTTP Secure)
is a communications protocol for secure communication over a computer network which is widely used on the Internet.
HTTPS consists of communication over Hypertext Transfer Protocol (HTTP) within a connection encrypted by Transport Layer Security,
or its predecessor, Secure Sockets Layer. The main motivation for HTTPS is authentication of the visited website
and protection of the privacy and integrity of the exchanged data.
Client-server applications use the TLS protocol to communicate across a network in a way designed to prevent eavesdropping and tampering.
SSL 1.0, 2.0 and 3.0
TLS 1.0 1999
TLS 1.1 2006
TLS 1.2 2008
TLS 1.3 (draft)
---------------------------------------------------------------------------------------------------------------------------
REST
look on rest.txt in this folder
--------------------------------------------------------------------------------------------------------------------------
WAR (Web application ARchive) files are used to distribute Java-based web applications.
A WAR has the same file structure as a JAR file, which is a single compressed file that contains multiple files bundled inside it.
WAR files are used to combine JSPs, servlets, Java class files, XML files, javascript libraries, JAR libraries, static web pages,
and any other resources needed to run the application.
WAR files are usually deployed in servlet containers, but can also be deployed to Java EE application servers.
When a WAR file is deployed to a container, the container usually unpacks it to access the files and then launches the application.
With servlet containers being the most prolific platform for Java web applications,
WAR files are not only a Java spec standard, but a very common format for distributing Java applications and
supported by a wide range of tools.
WAR plain structure:
example.war
   WEB-INF
           LIB
           CLASSES
           TAGS
           web.xml
   MEAT-INF


--------------------------------------------------------------------------------------------------------------------------
Servlet API

public interface javax.servlet.Servlet
Defines methods that all servlets must implement.A servlet is a small Java program that runs within a Web
Servlets receive and respond to requests from Web clients, usually across HTTP, the HyperText Transfer Protocol.
To implement this interface, you can write a generic servlet that extends javax.servlet.GenericServlet or an HTTP servlet that
extends javax.servlet.http.HttpServlet.

public abstract class javax.servlet.GenericServlet  implements Servlet, ServletConfig, java.io.Serializable
 makes writing servlets
easier. It provides simple versions of the lifecycle methods
<code>init</code> and <code>destroy</code> and of the methods
in the <code>ServletConfig</code> interface. <code>GenericServlet</code>
also implements the <code>log</code> method, declared in the
<code>ServletContext</code> interface.

public abstract class javax.servlet.http.HttpServlet extends GenericServlet
Provides an abstract class to be subclassed to create an HTTP servlet suitable for a Web site.

Session
Session attributes

-----------------------------------------------

MVC pattern
write application that return current date for client by three ways: socket,servlet,spring mvc.
write servlets stateful amd stateless(for example using cookies for shop cart)
write spring mvc controllers
spring security

XML
JSON
what is better?
http://www.yegor256.com/2015/11/16/json-vs-xml.html


Server

Another Servers

DB
jvm params(http://www.javaspecialist.ru/2011/04/java-thread-stack.html)
http://www.javaspecialist.ru/2011/04/permanent.html

ear vs war







































